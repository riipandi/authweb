import { consola } from 'consola'
import { type Options as MinifyOptions, minify } from 'html-minifier'
import { Liquid, type LiquidOptions } from 'liquidjs'
import { resolve } from 'pathe'
import { isProduction } from 'std-env'

const logger = consola.withTag('liquid')

// Configuration constants
const TEMPLATE_CONFIG = {
  storageKey: 'assets:views',
  extension: '.liquid',
  skipCacheTemplates: ['index', 'blog'] as const,
  cacheMaxAge: 60 * 60 * 24, // 24 hours
} as const

type SkipCacheTemplate = (typeof TEMPLATE_CONFIG.skipCacheTemplates)[number]

// Custom error class
class LiquidTemplateError extends Error {
  constructor(
    message: string,
    public statusCode = 500,
    public templatePath?: string
  ) {
    super(message)
    this.name = 'LiquidTemplateError'
  }
}

/**
 * Configuration for Liquid template engine
 */
const LIQUID_ENGINE_CONFIG: LiquidOptions = {
  root: [resolve('server/views')],
  cache: !process.dev,
  extname: TEMPLATE_CONFIG.extension,
  trimTagRight: true,
  strictVariables: true,
  strictFilters: true,
  globals: {
    now: new Date(),
    env: process.env.NODE_ENV,
  },
} as const

/**
 * HTML Minification options
 */
const MINIFY_OPTIONS: MinifyOptions = {
  html5: true,
  caseSensitive: true,
  collapseWhitespace: !process.dev,
  includeAutoGeneratedTags: true,
  maxLineLength: 240,
  preserveLineBreaks: false,
  removeComments: true,
  removeEmptyAttributes: true,
  removeRedundantAttributes: true,
  removeScriptTypeAttributes: true,
  removeStyleLinkTypeAttributes: true,
  sortClassName: false,
  useShortDoctype: true,
  minifyCSS: !process.dev,
  minifyJS: !process.dev,
} as const

// Template engine instance cache
let liquidEngine: Liquid | null = null

/**
 * Gets or creates Liquid engine instance
 */
function getLiquidEngine(): Liquid {
  if (!liquidEngine) {
    liquidEngine = new Liquid(LIQUID_ENGINE_CONFIG)
  }
  return liquidEngine
}

/**
 * Renders a Liquid template with caching support
 */
export const renderCachedTemplate = defineCachedFunction(
  async (templatePath: string, context?: Record<string, unknown>) => {
    try {
      return await renderTemplate(templatePath, context)
    } catch (error) {
      logger.error({
        message: 'Template render failed',
        templatePath,
        error,
      })
      throw error
    }
  },
  {
    shouldBypassCache: (templatePath: string): boolean => {
      const shouldSkipCache = TEMPLATE_CONFIG.skipCacheTemplates.includes(
        templatePath.replace('pages:', '') as SkipCacheTemplate
      )
      const isBlogPost = /^pages:blog\/.+/.test(templatePath)
      return !isProduction || shouldSkipCache || isBlogPost
    },
    name: 'liquid-template',
    maxAge: TEMPLATE_CONFIG.cacheMaxAge,
    swr: true,
  }
)

/**
 * Renders a Liquid template from storage
 */
export async function renderTemplate(
  templatePath: string,
  context?: Record<string, unknown>
): Promise<string> {
  const templateStorage = useStorage(TEMPLATE_CONFIG.storageKey)
  const templateContent = await templateStorage.getItem<string>(
    `${templatePath}${TEMPLATE_CONFIG.extension}`
  )

  if (!templateContent) {
    throw new LiquidTemplateError(
      `Template not found: ${templatePath}`,
      404,
      templatePath
    )
  }

  try {
    const engine = getLiquidEngine()
    const htmlContent = await engine.parseAndRender(templateContent, {
      ...context,
      renderTime: new Date(),
    })

    return minify(htmlContent, MINIFY_OPTIONS)
  } catch (error) {
    logger.error(error)
    throw new LiquidTemplateError('Template render failed', 500, templatePath)
  }
}

export { LiquidTemplateError }
